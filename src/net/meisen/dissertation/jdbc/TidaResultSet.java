package net.meisen.dissertation.jdbc;

import java.io.InputStream;
import java.io.Reader;
import java.math.BigDecimal;
import java.net.URL;
import java.sql.Array;
import java.sql.Blob;
import java.sql.Clob;
import java.sql.Date;
import java.sql.NClob;
import java.sql.Ref;
import java.sql.ResultSet;
import java.sql.ResultSetMetaData;
import java.sql.RowId;
import java.sql.SQLException;
import java.sql.SQLWarning;
import java.sql.SQLXML;
import java.sql.Statement;
import java.sql.Time;
import java.sql.Timestamp;
import java.util.Arrays;
import java.util.Calendar;
import java.util.Map;

import net.meisen.dissertation.jdbc.protocol.DataType;
import net.meisen.dissertation.jdbc.protocol.Protocol;
import net.meisen.dissertation.jdbc.protocol.QueryStatus;

/**
 * A {@code ResultSet} of a {@code TidaDatabase}.
 * 
 * @author pmeisen
 * 
 */
public class TidaResultSet extends BaseConnectionWrapper implements ResultSet {
	private final String sql;
	private final QueryResponseHandler handler;

	private final int resultSetHoldability;
	private final int resultSetType;
	private final int resultSetConcurrency;

	/**
	 * The constructor of the {@code TidaResultSet}. The constructor verifies if
	 * the created {@code ResultSet} is of the {@code expectedType} if not an
	 * exception is thrown.
	 * 
	 * @param statement
	 *            the {@code TidaStatement} which created the result-set
	 * @param sql
	 *            the query to be fired
	 * @param expectedType
	 *            the expected {@code TidaResultSetType}, which might be
	 *            {@link TidaResultSetType#UNKNOWN}
	 * @param resultSetType
	 *            the type, only {@link #TYPE_FORWARD_ONLY} is supported
	 * @param resultSetConcurrency
	 *            the concurrency, only {@link #CONCUR_READ_ONLY} is supported
	 * @param resultSetHoldability
	 *            the holdability, only {@link #CLOSE_CURSORS_AT_COMMIT} or
	 *            {@link #HOLD_CURSORS_OVER_COMMIT } is supported
	 * @param autoGeneratedKeys
	 *            a value of {@link Statement#RETURN_GENERATED_KEYS} or
	 *            {@link Statement#NO_GENERATED_KEYS}
	 * @param columnIndexes
	 *            the indexes of the columns to retrieve the key from, must be
	 *            empty or null
	 * @param columnNames
	 *            the names of the columns to retrieve the key from, must be
	 *            empty or null
	 * 
	 * @throws SQLException
	 *             if the connection cannot be established, if the
	 *             {@code expectedType} is not valid, if an invalid value is
	 *             used for type, concurrency, or holdability
	 */
	public TidaResultSet(final TidaStatement statement, final String sql,
			final TidaResultSetType expectedType, final int resultSetType,
			final int resultSetConcurrency, final int resultSetHoldability,
			final int autoGeneratedKeys, final int[] columnIndexes,
			final String[] columnNames) throws SQLException {
		super(statement);

		// check the query
		if (sql == null) {
			throw TidaSqlExceptions.createException(4004);
		}

		// check the resultSet settings
		if (resultSetType == ResultSet.TYPE_FORWARD_ONLY) {
			this.resultSetType = resultSetType;
		} else if (resultSetType == ResultSet.TYPE_SCROLL_INSENSITIVE
				|| resultSetType == ResultSet.TYPE_SCROLL_SENSITIVE) {
			throw TidaSqlExceptions.createNotSupportedException(4013, ""
					+ resultSetType);
		} else {
			throw TidaSqlExceptions.createException(4014, "" + resultSetType);
		}

		if (resultSetConcurrency == ResultSet.CONCUR_READ_ONLY) {
			this.resultSetConcurrency = resultSetConcurrency;
		} else if (resultSetConcurrency == ResultSet.CONCUR_UPDATABLE) {
			throw TidaSqlExceptions.createNotSupportedException(4015, ""
					+ resultSetType);
		} else {
			throw TidaSqlExceptions.createException(4016, "" + resultSetType);
		}

		if (resultSetHoldability == ResultSet.CLOSE_CURSORS_AT_COMMIT
				|| resultSetHoldability == ResultSet.HOLD_CURSORS_OVER_COMMIT) {
			this.resultSetHoldability = resultSetHoldability;
		} else {
			throw TidaSqlExceptions.createException(4017, "" + resultSetType);
		}

		if (autoGeneratedKeys != Statement.RETURN_GENERATED_KEYS
				&& autoGeneratedKeys != Statement.NO_GENERATED_KEYS) {
			throw TidaSqlExceptions.createException(4024, ""
					+ autoGeneratedKeys);
		}

		// create the handler for the resultSet
		final String handlerClass = statement.getDriverProperties()
				.getHandlerClass();
		try {
			@SuppressWarnings("unchecked")
			final Class<? extends QueryResponseHandler> clazz = (Class<? extends QueryResponseHandler>) Class
					.forName(handlerClass);
			this.handler = clazz.newInstance();
		} catch (final Exception e) {
			throw TidaSqlExceptions.createException(4003, e, handlerClass);
		}

		// set the SQL statement
		this.sql = sql;

		// determine the status we need
		final QueryStatus status;
		if (Statement.RETURN_GENERATED_KEYS == autoGeneratedKeys) {
			if ((columnIndexes != null && columnIndexes.length != 0)
					|| (columnNames != null && columnNames.length != 0)) {

				throw TidaSqlExceptions.createNotSupportedException(4020);
			}
			status = QueryStatus.PROCESSANDGETIDS;
		} else {
			status = QueryStatus.PROCESS;
		}

		// pre-validate the retrieval of identifiers
		if (TidaResultSetType.QUERY.equals(expectedType)
				&& QueryStatus.PROCESSANDGETIDS.equals(status)) {
			throw TidaSqlExceptions.createException(4021);
		}

		// set the handler expectations
		handler.setExpectedResultSetType(expectedType);
		handler.setQueryStatus(status);

		// fire the query
		try {
			initialize(sql);
		} catch (final SQLException e) {

			// finalize anything
			getProtocol().markCommunicationAsFinal(handler);

			// close the connection in the case of an exception
			close();

			// keep the exception to be thrown
			throw e;
		}
	}

	@Override
	public void close() throws SQLException {
		if (isClosed()) {
			return;
		}

		/*
		 * If we expect data on the handler, we have to wait until an EOR was
		 * send.
		 */
		if (TidaResultSetType.QUERY.equals(handler.getResultSetType())
				&& !handler.isEOR()) {

			// make sure that the protocol cancels if needed
			Thread.currentThread().interrupt();

			// wait until the protocol tells the system that the connection is
			// closed
			final Protocol protocol = getProtocol();
			try {
				while (!protocol.handleResponse(handler)) {
					// just read the next one, the end must be reached
				}
			} catch (final Exception e) {
				/*
				 * Ignore it, the connection is closed from server side, or an
				 * exception was thrown from server side. In both cases
				 * everything should be fine and handled later on.
				 */
			}
		}

		super.close();
	}

	/**
	 * Initializes the {@code ResultSet} with the specified {@code sql} query.
	 * 
	 * @param sql
	 *            the query to be initialized
	 * 
	 * @throws SQLException
	 *             if the query fails or cannot be initialized
	 */
	protected void initialize(final String sql) throws SQLException {

		if (fireQuery(sql, handler)) {
			if (TidaResultSetType.MODIFY.equals(handler.getResultSetType())) {
				/*
				 * Handle the complete modification at once. There is no data to
				 * be retrieved, which is retrieved in chunks.
				 */
				while (!handler.isEOR()) {
					handleResponse(handler);
				}

				// we don't need the connection anymore, so just release it
				release();
			} else {

				// check if we receive identifiers for a query statement
				if (TidaResultSetType.QUERY.equals(handler.getResultSetType())
						&& QueryStatus.PROCESSANDGETIDS.equals(handler
								.getQueryStatus())) {
					throw TidaSqlExceptions.createException(4021);
				}

				/*
				 * Read the meta-data of the handler, no data should be read so
				 * far. Therefore after the handling the header should be known
				 * as well as no result should have been read.
				 */
				handleResponse(handler);
				if (handler.getLastResult() != null) {
					throw TidaSqlExceptions.createException(4025);
				} else if (handler.getHeader() == null) {
					throw TidaSqlExceptions.createException(4026);
				}
			}
		}
		// we have a modifying statement, but an update was expected
		else if (TidaResultSetType.MODIFY.equals(handler.getResultSetType())) {
			throw TidaSqlExceptions.createException(4006, sql);
		}
		// we have a query-statement, but a modifying was expected
		else if (TidaResultSetType.QUERY.equals(handler.getResultSetType())) {
			throw TidaSqlExceptions.createException(4005, sql);
		} else {
			throw TidaSqlExceptions.createException(4027, sql);
		}
	}

	/**
	 * Checks if {@code this} result-set is of the type specified by
	 * {@code expectedType}.
	 * 
	 * @param expectedType
	 *            the expected type
	 * 
	 * @return {@code true} if the expectation is equal to {@code this} type,
	 *         otherwise {@code false}
	 */
	public boolean isResultSetType(final TidaResultSetType expectedType) {
		return handler.getResultSetType().equals(expectedType);
	}

	@Override
	protected BaseConnectionWrapper getProtocolScope() {
		return getParent();
	}

	@Override
	protected boolean doCloseOnCommit() {
		return resultSetHoldability == ResultSet.CLOSE_CURSORS_AT_COMMIT;
	}

	/**
	 * Checks if the {@code ResultSet} is closed, if so an exception is thrown,
	 * otherwise nothing happens.
	 * 
	 * @throws SQLException
	 *             if the {@code ResultSet} is closed
	 * 
	 * @see #isClosed()
	 */
	protected void checkClosed() throws SQLException {
		if (isClosed()) {
			throw TidaSqlExceptions.createException(4999);
		}
	}

	@Override
	public boolean next() throws SQLException {
		checkClosed();

		if (handler.reachedEOR()) {
			return false;
		} else {

			// read the next one
			handleResponse(handler);

			// if no eor there was a next
			return !handler.reachedEOR();
		}
	}

	/**
	 * Gets the last result retrieved from {@code this}.
	 * 
	 * @return the last result retrieved
	 */
	public Object[] getLastResult() {
		return handler.getLastResult();
	}

	/**
	 * Gets the value of the last-result at the specified {@code columnIndex}.
	 * The method also checks if the specified {@code clazz}-type is applicable.
	 * 
	 * @param columnIndex
	 *            the column to get the value from
	 * @param clazz
	 *            the type of the value
	 * 
	 * @return the value of the {@code columnIndex}
	 * 
	 * @throws SQLException
	 *             if the {@code columnIndex} is invalid or the {@code clazz}
	 *             cannot be mapped
	 */
	@SuppressWarnings("unchecked")
	public <T> T getValue(final int columnIndex, final Class<T> clazz)
			throws SQLException {
		checkClosed();

		// get the position
		final int pos = columnIndex - 1;

		// get the value
		if (handler.isValidHeaderType(pos, clazz)) {
			return handler.cast(pos, clazz);
		} else if (Number.class.isAssignableFrom(clazz)
				&& handler.isInteger(pos)) {
			return (T) handler.toInteger(pos, (Class<? extends Number>) clazz);
		} else if (String.class.equals(clazz)) {
			return (T) handler.toString(pos);
		} else {
			throw TidaSqlExceptions.createException(4022, "" + columnIndex,
					clazz.getName());
		}
	}

	@Override
	public boolean wasNull() throws SQLException {
		checkClosed();

		return false;
	}

	@Override
	public String getString(final int columnIndex) throws SQLException {
		return getValue(columnIndex, String.class);
	}

	@Override
	public boolean getBoolean(final int columnIndex) throws SQLException {
		return getValue(columnIndex, Boolean.class);
	}

	@Override
	public byte getByte(final int columnIndex) throws SQLException {
		return getValue(columnIndex, Byte.class);
	}

	@Override
	public short getShort(final int columnIndex) throws SQLException {
		return getValue(columnIndex, Short.class);
	}

	@Override
	public int getInt(final int columnIndex) throws SQLException {
		return getValue(columnIndex, Integer.class);
	}

	@Override
	public long getLong(final int columnIndex) throws SQLException {
		return getValue(columnIndex, Long.class);
	}

	@Override
	public float getFloat(final int columnIndex) throws SQLException {
		return getValue(columnIndex, Float.class);
	}

	@Override
	public double getDouble(final int columnIndex) throws SQLException {
		return getValue(columnIndex, Double.class);
	}

	@Override
	@Deprecated
	public BigDecimal getBigDecimal(final int columnIndex, final int scale)
			throws SQLException {
		return getValue(columnIndex, BigDecimal.class).setScale(scale);
	}

	@Override
	public byte[] getBytes(final int columnIndex) throws SQLException {
		return getValue(columnIndex, byte[].class);
	}

	@Override
	public Date getDate(final int columnIndex) throws SQLException {
		return getDate(columnIndex, null);
	}

	@Override
	public Time getTime(final int columnIndex) throws SQLException {
		return getTime(columnIndex, null);
	}

	@Override
	public Timestamp getTimestamp(final int columnIndex) throws SQLException {
		return getTimestamp(columnIndex, null);
	}

	@Override
	public InputStream getAsciiStream(final int columnIndex)
			throws SQLException {
		return getValue(columnIndex, InputStream.class);
	}

	@Override
	@Deprecated
	public InputStream getUnicodeStream(final int columnIndex)
			throws SQLException {
		return getValue(columnIndex, InputStream.class);
	}

	@Override
	public InputStream getBinaryStream(final int columnIndex)
			throws SQLException {
		return getValue(columnIndex, InputStream.class);
	}

	@Override
	public String getString(final String columnLabel) throws SQLException {
		return getString(findColumn(columnLabel));
	}

	@Override
	public boolean getBoolean(final String columnLabel) throws SQLException {
		return getBoolean(findColumn(columnLabel));
	}

	@Override
	public byte getByte(final String columnLabel) throws SQLException {
		return getByte(findColumn(columnLabel));
	}

	@Override
	public short getShort(final String columnLabel) throws SQLException {
		return getShort(findColumn(columnLabel));
	}

	@Override
	public int getInt(final String columnLabel) throws SQLException {
		return getInt(findColumn(columnLabel));
	}

	@Override
	public long getLong(final String columnLabel) throws SQLException {
		return getLong(findColumn(columnLabel));
	}

	@Override
	public float getFloat(final String columnLabel) throws SQLException {
		return getFloat(findColumn(columnLabel));
	}

	@Override
	public double getDouble(final String columnLabel) throws SQLException {
		return getDouble(findColumn(columnLabel));
	}

	@Override
	@Deprecated
	public BigDecimal getBigDecimal(final String columnLabel, final int scale)
			throws SQLException {
		return getBigDecimal(findColumn(columnLabel), scale);
	}

	@Override
	public byte[] getBytes(final String columnLabel) throws SQLException {
		return getBytes(findColumn(columnLabel));
	}

	@Override
	public Date getDate(final String columnLabel) throws SQLException {
		return getDate(findColumn(columnLabel));
	}

	@Override
	public Time getTime(final String columnLabel) throws SQLException {
		return getTime(findColumn(columnLabel));
	}

	@Override
	public Timestamp getTimestamp(final String columnLabel) throws SQLException {
		return getTimestamp(findColumn(columnLabel));
	}

	@Override
	public InputStream getAsciiStream(final String columnLabel)
			throws SQLException {
		return getAsciiStream(findColumn(columnLabel));
	}

	@Override
	@Deprecated
	public InputStream getUnicodeStream(final String columnLabel)
			throws SQLException {
		return getUnicodeStream(findColumn(columnLabel));
	}

	@Override
	public InputStream getBinaryStream(final String columnLabel)
			throws SQLException {
		return getBinaryStream(findColumn(columnLabel));
	}

	@Override
	public SQLWarning getWarnings() throws SQLException {
		checkClosed();

		return new SQLWarning();
	}

	@Override
	public void clearWarnings() throws SQLException {
		checkClosed();
	}

	@Override
	public String getCursorName() throws SQLException {
		checkClosed();

		return sql == null ? "" : sql;
	}

	@Override
	public ResultSetMetaData getMetaData() throws SQLException {
		checkClosed();

		return new TidaResultSetMetaData(this);
	}

	@Override
	public Object getObject(final int columnIndex) throws SQLException {
		return getValue(columnIndex, Object.class);
	}

	@Override
	public Object getObject(final String columnLabel) throws SQLException {
		return getObject(findColumn(columnLabel));
	}

	/**
	 * Gets the {@code DataType} of the column.
	 * 
	 * @param columnIndex
	 *            the number of the column to get the type for
	 * 
	 * @return the {@code DataType} of the column or {@code null} if the index
	 *         is invalid
	 */
	public DataType getHeaderType(final int columnIndex) {
		return handler.getHeaderType(columnIndex - 1);
	}

	/**
	 * Gets the label of the column.
	 * 
	 * @param columnIndex
	 *            the number of the column to get the label for
	 * 
	 * @return the label of the column or {@code null} if the index is invalid
	 */
	public String getHeaderLabel(final int columnIndex) {
		return handler.getHeaderName(columnIndex - 1);
	}

	@Override
	public int findColumn(final String columnLabel) throws SQLException {
		checkClosed();

		final int pos = handler.getHeaderPosition(columnLabel);
		if (pos >= 0) {
			return pos + 1;
		} else {
			throw TidaSqlExceptions.createException(4023, columnLabel, Arrays
					.asList(handler.getHeaderNames()).toString());
		}
	}

	/**
	 * Gets the defined types of the header of the result-set.
	 * 
	 * @return the defined types of the header
	 */
	public DataType[] getHeaderTypes() {
		return handler.getHeader();
	}

	@Override
	public Reader getCharacterStream(final int columnIndex) throws SQLException {
		return getValue(columnIndex, Reader.class);
	}

	@Override
	public Reader getCharacterStream(final String columnLabel)
			throws SQLException {
		return getCharacterStream(findColumn(columnLabel));
	}

	@Override
	public BigDecimal getBigDecimal(final int columnIndex) throws SQLException {
		return getValue(columnIndex, BigDecimal.class);
	}

	@Override
	public BigDecimal getBigDecimal(final String columnLabel)
			throws SQLException {
		return getBigDecimal(findColumn(columnLabel));
	}

	@Override
	public boolean isBeforeFirst() throws SQLException {
		checkClosed();

		return handler.getLastResult() == null;
	}

	@Override
	public boolean isAfterLast() throws SQLException {
		checkClosed();

		return handler.reachedEOR();
	}

	@Override
	public boolean isFirst() throws SQLException {
		checkClosed();

		throw TidaSqlExceptions.createException(4007);
	}

	@Override
	public boolean isLast() throws SQLException {
		checkClosed();

		throw TidaSqlExceptions.createException(4007);
	}

	@Override
	public void beforeFirst() throws SQLException {
		checkClosed();

		throw TidaSqlExceptions.createException(4007);
	}

	@Override
	public void afterLast() throws SQLException {
		checkClosed();

		throw TidaSqlExceptions.createException(4007);
	}

	@Override
	public boolean first() throws SQLException {
		checkClosed();

		throw TidaSqlExceptions.createException(4007);
	}

	@Override
	public boolean last() throws SQLException {
		checkClosed();

		throw TidaSqlExceptions.createException(4007);
	}

	@Override
	public int getRow() throws SQLException {
		checkClosed();

		throw TidaSqlExceptions.createException(4007);
	}

	@Override
	public boolean absolute(final int row) throws SQLException {
		checkClosed();

		throw TidaSqlExceptions.createException(4007);
	}

	@Override
	public boolean relative(final int rows) throws SQLException {
		checkClosed();

		throw TidaSqlExceptions.createException(4007);
	}

	@Override
	public boolean previous() throws SQLException {
		checkClosed();

		throw TidaSqlExceptions.createException(4007);
	}

	@Override
	public void setFetchDirection(final int direction) throws SQLException {
		checkClosed();

		if (direction != ResultSet.FETCH_FORWARD) {
			throw TidaSqlExceptions.createNotSupportedException(4000, ""
					+ direction);
		}
	}

	@Override
	public int getFetchDirection() throws SQLException {
		checkClosed();

		return ResultSet.FETCH_FORWARD;
	}

	@Override
	public void setFetchSize(final int rows) throws SQLException {
		checkClosed();

		if (rows > 1) {
			throw TidaSqlExceptions
					.createNotSupportedException(4001, "" + rows);
		} else if (rows < 0) {
			throw TidaSqlExceptions.createException(4002, "" + rows);
		}
	}

	@Override
	public int getFetchSize() throws SQLException {
		checkClosed();

		return 1;
	}

	@Override
	public int getType() throws SQLException {
		checkClosed();

		return resultSetType;
	}

	@Override
	public int getConcurrency() throws SQLException {
		checkClosed();

		return resultSetConcurrency;
	}

	@Override
	public boolean rowUpdated() throws SQLException {
		checkClosed();

		throw TidaSqlExceptions.createException(4008);
	}

	@Override
	public boolean rowInserted() throws SQLException {
		checkClosed();

		throw TidaSqlExceptions.createException(4008);
	}

	@Override
	public boolean rowDeleted() throws SQLException {
		checkClosed();

		throw TidaSqlExceptions.createException(4008);
	}

	@Override
	public void updateNull(final int columnIndex) throws SQLException {
		checkClosed();

		throw TidaSqlExceptions.createException(4009);
	}

	@Override
	public void updateBoolean(final int columnIndex, final boolean x)
			throws SQLException {
		checkClosed();

		throw TidaSqlExceptions.createException(4009);
	}

	@Override
	public void updateByte(final int columnIndex, final byte x)
			throws SQLException {
		checkClosed();

		throw TidaSqlExceptions.createException(4009);
	}

	@Override
	public void updateShort(final int columnIndex, final short x)
			throws SQLException {
		checkClosed();

		throw TidaSqlExceptions.createException(4009);
	}

	@Override
	public void updateInt(final int columnIndex, final int x)
			throws SQLException {
		checkClosed();

		throw TidaSqlExceptions.createException(4009);
	}

	@Override
	public void updateLong(final int columnIndex, final long x)
			throws SQLException {
		checkClosed();

		throw TidaSqlExceptions.createException(4009);
	}

	@Override
	public void updateFloat(final int columnIndex, final float x)
			throws SQLException {
		checkClosed();

		throw TidaSqlExceptions.createException(4009);
	}

	@Override
	public void updateDouble(final int columnIndex, final double x)
			throws SQLException {
		checkClosed();

		throw TidaSqlExceptions.createException(4009);
	}

	@Override
	public void updateBigDecimal(final int columnIndex, final BigDecimal x)
			throws SQLException {
		checkClosed();

		throw TidaSqlExceptions.createException(4009);
	}

	@Override
	public void updateString(final int columnIndex, final String x)
			throws SQLException {
		checkClosed();

		throw TidaSqlExceptions.createException(4009);
	}

	@Override
	public void updateBytes(final int columnIndex, final byte[] x)
			throws SQLException {
		checkClosed();

		throw TidaSqlExceptions.createException(4009);
	}

	@Override
	public void updateDate(final int columnIndex, final Date x)
			throws SQLException {
		checkClosed();

		throw TidaSqlExceptions.createException(4009);
	}

	@Override
	public void updateTime(final int columnIndex, final Time x)
			throws SQLException {
		checkClosed();

		throw TidaSqlExceptions.createException(4009);
	}

	@Override
	public void updateTimestamp(final int columnIndex, final Timestamp x)
			throws SQLException {
		checkClosed();

		throw TidaSqlExceptions.createException(4009);
	}

	@Override
	public void updateAsciiStream(final int columnIndex, final InputStream x,
			final int length) throws SQLException {
		checkClosed();

		throw TidaSqlExceptions.createException(4009);
	}

	@Override
	public void updateBinaryStream(final int columnIndex, final InputStream x,
			final int length) throws SQLException {
		checkClosed();

		throw TidaSqlExceptions.createException(4009);
	}

	@Override
	public void updateCharacterStream(final int columnIndex, final Reader x,
			final int length) throws SQLException {
		checkClosed();

		throw TidaSqlExceptions.createException(4009);
	}

	@Override
	public void updateObject(final int columnIndex, final Object x,
			final int scaleOrLength) throws SQLException {
		checkClosed();

		throw TidaSqlExceptions.createException(4009);
	}

	@Override
	public void updateObject(final int columnIndex, final Object x)
			throws SQLException {
		checkClosed();

		throw TidaSqlExceptions.createException(4009);
	}

	@Override
	public void updateNull(final String columnLabel) throws SQLException {
		checkClosed();

		throw TidaSqlExceptions.createException(4009);
	}

	@Override
	public void updateBoolean(final String columnLabel, final boolean x)
			throws SQLException {
		checkClosed();

		throw TidaSqlExceptions.createException(4009);
	}

	@Override
	public void updateByte(final String columnLabel, final byte x)
			throws SQLException {
		checkClosed();

		throw TidaSqlExceptions.createException(4009);
	}

	@Override
	public void updateShort(final String columnLabel, final short x)
			throws SQLException {
		checkClosed();

		throw TidaSqlExceptions.createException(4009);
	}

	@Override
	public void updateInt(final String columnLabel, final int x)
			throws SQLException {
		checkClosed();

		throw TidaSqlExceptions.createException(4009);
	}

	@Override
	public void updateLong(final String columnLabel, final long x)
			throws SQLException {
		checkClosed();

		throw TidaSqlExceptions.createException(4009);
	}

	@Override
	public void updateFloat(final String columnLabel, final float x)
			throws SQLException {
		checkClosed();

		throw TidaSqlExceptions.createException(4009);
	}

	@Override
	public void updateDouble(final String columnLabel, final double x)
			throws SQLException {
		checkClosed();

		throw TidaSqlExceptions.createException(4009);
	}

	@Override
	public void updateBigDecimal(final String columnLabel, final BigDecimal x)
			throws SQLException {
		checkClosed();

		throw TidaSqlExceptions.createException(4009);
	}

	@Override
	public void updateString(final String columnLabel, final String x)
			throws SQLException {
		checkClosed();

		throw TidaSqlExceptions.createException(4009);
	}

	@Override
	public void updateBytes(final String columnLabel, final byte[] x)
			throws SQLException {
		checkClosed();

		throw TidaSqlExceptions.createException(4009);
	}

	@Override
	public void updateDate(final String columnLabel, final Date x)
			throws SQLException {
		checkClosed();

		throw TidaSqlExceptions.createException(4009);
	}

	@Override
	public void updateTime(final String columnLabel, final Time x)
			throws SQLException {
		checkClosed();

		throw TidaSqlExceptions.createException(4009);
	}

	@Override
	public void updateTimestamp(final String columnLabel, final Timestamp x)
			throws SQLException {
		checkClosed();

		throw TidaSqlExceptions.createException(4009);
	}

	@Override
	public void updateAsciiStream(final String columnLabel,
			final InputStream x, final int length) throws SQLException {
		checkClosed();

		throw TidaSqlExceptions.createException(4009);
	}

	@Override
	public void updateBinaryStream(final String columnLabel,
			final InputStream x, final int length) throws SQLException {
		checkClosed();

		throw TidaSqlExceptions.createException(4009);
	}

	@Override
	public void updateCharacterStream(final String columnLabel,
			final Reader reader, final int length) throws SQLException {
		checkClosed();

		throw TidaSqlExceptions.createException(4009);
	}

	@Override
	public void updateObject(final String columnLabel, final Object x,
			final int scaleOrLength) throws SQLException {
		checkClosed();

		throw TidaSqlExceptions.createException(4009);
	}

	@Override
	public void updateObject(final String columnLabel, final Object x)
			throws SQLException {
		checkClosed();

		throw TidaSqlExceptions.createException(4009);
	}

	@Override
	public void insertRow() throws SQLException {
		checkClosed();

		throw TidaSqlExceptions.createException(4010);
	}

	@Override
	public void updateRow() throws SQLException {
		checkClosed();

		throw TidaSqlExceptions.createException(4009);
	}

	@Override
	public void deleteRow() throws SQLException {
		checkClosed();

		throw TidaSqlExceptions.createException(4011);
	}

	@Override
	public void refreshRow() throws SQLException {
		checkClosed();

		throw TidaSqlExceptions.createException(4007);
	}

	@Override
	public void cancelRowUpdates() throws SQLException {
		checkClosed();

		throw TidaSqlExceptions.createException(4012);
	}

	@Override
	public void moveToInsertRow() throws SQLException {
		checkClosed();

		throw TidaSqlExceptions.createException(4012);
	}

	@Override
	public void moveToCurrentRow() throws SQLException {
		checkClosed();

		throw TidaSqlExceptions.createException(4012);
	}

	@Override
	public Statement getStatement() throws SQLException {
		return (TidaStatement) getParent();
	}

	@Override
	public Object getObject(final int columnIndex,
			final Map<String, Class<?>> map) throws SQLException {
		return getValue(columnIndex, Object.class);
	}

	@Override
	public Ref getRef(final int columnIndex) throws SQLException {
		return getValue(columnIndex, Ref.class);
	}

	@Override
	public Blob getBlob(final int columnIndex) throws SQLException {
		return getValue(columnIndex, Blob.class);
	}

	@Override
	public Clob getClob(final int columnIndex) throws SQLException {
		return getValue(columnIndex, Clob.class);
	}

	@Override
	public Array getArray(final int columnIndex) throws SQLException {
		return getValue(columnIndex, Array.class);
	}

	@Override
	public Object getObject(final String columnLabel,
			final Map<String, Class<?>> map) throws SQLException {
		return getObject(findColumn(columnLabel), map);
	}

	@Override
	public Ref getRef(final String columnLabel) throws SQLException {
		return getRef(findColumn(columnLabel));
	}

	@Override
	public Blob getBlob(final String columnLabel) throws SQLException {
		return getBlob(findColumn(columnLabel));
	}

	@Override
	public Clob getClob(final String columnLabel) throws SQLException {
		return getClob(findColumn(columnLabel));
	}

	@Override
	public Array getArray(final String columnLabel) throws SQLException {
		return getArray(findColumn(columnLabel));
	}

	@Override
	public Date getDate(final int columnIndex, final Calendar cal)
			throws SQLException {
		if (cal == null) {
			final java.util.Date d = getValue(columnIndex, java.util.Date.class);
			return new Date(d.getTime());
		} else {
			final Date d = getDate(columnIndex);
			cal.setTimeInMillis(d.getTime());
			return new Date(cal.getTime().getTime());
		}
	}

	@Override
	public Date getDate(final String columnLabel, final Calendar cal)
			throws SQLException {
		return getDate(findColumn(columnLabel), cal);
	}

	@Override
	public Time getTime(final int columnIndex, final Calendar cal)
			throws SQLException {
		if (cal == null) {
			final java.util.Date d = getValue(columnIndex, java.util.Date.class);
			return new Time(d.getTime());
		} else {
			final Date d = getDate(columnIndex);
			cal.setTimeInMillis(d.getTime());
			return new Time(cal.getTime().getTime());
		}
	}

	@Override
	public Time getTime(final String columnLabel, final Calendar cal)
			throws SQLException {
		return getTime(findColumn(columnLabel), cal);
	}

	@Override
	public Timestamp getTimestamp(final int columnIndex, final Calendar cal)
			throws SQLException {
		if (cal == null) {
			final java.util.Date d = getValue(columnIndex, java.util.Date.class);
			return new Timestamp(d.getTime());
		} else {
			final Date d = getDate(columnIndex);
			cal.setTimeInMillis(d.getTime());
			return new Timestamp(cal.getTime().getTime());
		}
	}

	@Override
	public Timestamp getTimestamp(final String columnLabel, final Calendar cal)
			throws SQLException {
		return getTimestamp(findColumn(columnLabel), cal);
	}

	@Override
	public URL getURL(final int columnIndex) throws SQLException {
		return getValue(columnIndex, URL.class);
	}

	@Override
	public URL getURL(final String columnLabel) throws SQLException {
		return getURL(findColumn(columnLabel));
	}

	@Override
	public void updateRef(final int columnIndex, final Ref x)
			throws SQLException {
		checkClosed();

		throw TidaSqlExceptions.createException(4009);
	}

	@Override
	public void updateRef(final String columnLabel, final Ref x)
			throws SQLException {
		checkClosed();

		throw TidaSqlExceptions.createException(4009);
	}

	@Override
	public void updateBlob(final int columnIndex, final Blob x)
			throws SQLException {
		checkClosed();

		throw TidaSqlExceptions.createException(4009);
	}

	@Override
	public void updateBlob(final String columnLabel, final Blob x)
			throws SQLException {
		checkClosed();

		throw TidaSqlExceptions.createException(4009);
	}

	@Override
	public void updateClob(final int columnIndex, final Clob x)
			throws SQLException {
		checkClosed();

		throw TidaSqlExceptions.createException(4009);
	}

	@Override
	public void updateClob(final String columnLabel, final Clob x)
			throws SQLException {
		checkClosed();

		throw TidaSqlExceptions.createException(4009);
	}

	@Override
	public void updateArray(final int columnIndex, final Array x)
			throws SQLException {
		checkClosed();

		throw TidaSqlExceptions.createException(4009);
	}

	@Override
	public void updateArray(final String columnLabel, final Array x)
			throws SQLException {
		checkClosed();

		throw TidaSqlExceptions.createException(4009);
	}

	@Override
	public RowId getRowId(final int columnIndex) throws SQLException {
		checkClosed();

		throw TidaSqlExceptions.createNotSupportedException(4019);
	}

	@Override
	public RowId getRowId(final String columnLabel) throws SQLException {
		checkClosed();

		throw TidaSqlExceptions.createNotSupportedException(4019);
	}

	@Override
	public void updateRowId(final int columnIndex, final RowId x)
			throws SQLException {
		checkClosed();

		throw TidaSqlExceptions.createException(4009);
	}

	@Override
	public void updateRowId(final String columnLabel, final RowId x)
			throws SQLException {
		checkClosed();

		throw TidaSqlExceptions.createException(4009);
	}

	@Override
	public int getHoldability() throws SQLException {
		checkClosed();

		return resultSetHoldability;
	}

	@Override
	public void updateNString(int columnIndex, String nString)
			throws SQLException {
		checkClosed();

		throw TidaSqlExceptions.createException(4009);
	}

	@Override
	public void updateNString(String columnLabel, String nString)
			throws SQLException {
		checkClosed();

		throw TidaSqlExceptions.createException(4009);
	}

	@Override
	public void updateNClob(int columnIndex, NClob nClob) throws SQLException {
		checkClosed();

		throw TidaSqlExceptions.createException(4009);
	}

	@Override
	public void updateNClob(String columnLabel, NClob nClob)
			throws SQLException {
		checkClosed();

		throw TidaSqlExceptions.createException(4009);
	}

	@Override
	public NClob getNClob(int columnIndex) throws SQLException {
		return getValue(columnIndex, NClob.class);
	}

	@Override
	public NClob getNClob(final String columnLabel) throws SQLException {
		return getNClob(findColumn(columnLabel));
	}

	@Override
	public SQLXML getSQLXML(final int columnIndex) throws SQLException {
		throw TidaSqlExceptions.createException(4018);
	}

	@Override
	public SQLXML getSQLXML(final String columnLabel) throws SQLException {
		throw TidaSqlExceptions.createException(4018);
	}

	@Override
	public void updateSQLXML(final int columnIndex, final SQLXML xmlObject)
			throws SQLException {
		throw TidaSqlExceptions.createException(4018);
	}

	@Override
	public void updateSQLXML(final String columnLabel, final SQLXML xmlObject)
			throws SQLException {
		throw TidaSqlExceptions.createException(4018);
	}

	@Override
	public String getNString(final int columnIndex) throws SQLException {
		return getValue(columnIndex, String.class);
	}

	@Override
	public String getNString(final String columnLabel) throws SQLException {
		return getNString(findColumn(columnLabel));
	}

	@Override
	public Reader getNCharacterStream(final int columnIndex)
			throws SQLException {
		return getValue(columnIndex, Reader.class);
	}

	@Override
	public Reader getNCharacterStream(final String columnLabel)
			throws SQLException {
		return getNCharacterStream(findColumn(columnLabel));
	}

	@Override
	public void updateNCharacterStream(final int columnIndex, final Reader x,
			final long length) throws SQLException {
		checkClosed();

		throw TidaSqlExceptions.createException(4009);
	}

	@Override
	public void updateNCharacterStream(final String columnLabel,
			final Reader reader, long length) throws SQLException {
		checkClosed();

		throw TidaSqlExceptions.createException(4009);
	}

	@Override
	public void updateAsciiStream(final int columnIndex, final InputStream x,
			final long length) throws SQLException {
		checkClosed();

		throw TidaSqlExceptions.createException(4009);
	}

	@Override
	public void updateBinaryStream(final int columnIndex, final InputStream x,
			final long length) throws SQLException {
		checkClosed();

		throw TidaSqlExceptions.createException(4009);
	}

	@Override
	public void updateCharacterStream(final int columnIndex, final Reader x,
			final long length) throws SQLException {
		checkClosed();

		throw TidaSqlExceptions.createException(4009);
	}

	@Override
	public void updateAsciiStream(final String columnLabel,
			final InputStream x, final long length) throws SQLException {
		checkClosed();

		throw TidaSqlExceptions.createException(4009);
	}

	@Override
	public void updateBinaryStream(final String columnLabel,
			final InputStream x, long length) throws SQLException {
		checkClosed();

		throw TidaSqlExceptions.createException(4009);
	}

	@Override
	public void updateCharacterStream(final String columnLabel,
			final Reader reader, final long length) throws SQLException {
		checkClosed();

		throw TidaSqlExceptions.createException(4009);
	}

	@Override
	public void updateBlob(final int columnIndex,
			final InputStream inputStream, final long length)
			throws SQLException {
		checkClosed();

		throw TidaSqlExceptions.createException(4009);
	}

	@Override
	public void updateBlob(final String columnLabel,
			final InputStream inputStream, long length) throws SQLException {
		checkClosed();

		throw TidaSqlExceptions.createException(4009);
	}

	@Override
	public void updateClob(final int columnIndex, final Reader reader,
			final long length) throws SQLException {
		checkClosed();

		throw TidaSqlExceptions.createException(4009);
	}

	@Override
	public void updateClob(final String columnLabel, final Reader reader,
			final long length) throws SQLException {
		checkClosed();

		throw TidaSqlExceptions.createException(4009);
	}

	@Override
	public void updateNClob(final int columnIndex, final Reader reader,
			final long length) throws SQLException {
		checkClosed();

		throw TidaSqlExceptions.createException(4009);
	}

	@Override
	public void updateNClob(final String columnLabel, final Reader reader,
			final long length) throws SQLException {
		checkClosed();

		throw TidaSqlExceptions.createException(4009);
	}

	@Override
	public void updateNCharacterStream(final int columnIndex, final Reader x)
			throws SQLException {
		checkClosed();

		throw TidaSqlExceptions.createException(4009);
	}

	@Override
	public void updateNCharacterStream(final String columnLabel,
			final Reader reader) throws SQLException {
		checkClosed();

		throw TidaSqlExceptions.createException(4009);
	}

	@Override
	public void updateAsciiStream(final int columnIndex, final InputStream x)
			throws SQLException {
		checkClosed();

		throw TidaSqlExceptions.createException(4009);
	}

	@Override
	public void updateBinaryStream(final int columnIndex, final InputStream x)
			throws SQLException {
		checkClosed();

		throw TidaSqlExceptions.createException(4009);
	}

	@Override
	public void updateCharacterStream(final int columnIndex, final Reader x)
			throws SQLException {
		checkClosed();

		throw TidaSqlExceptions.createException(4009);
	}

	@Override
	public void updateAsciiStream(final String columnLabel, final InputStream x)
			throws SQLException {
		checkClosed();

		throw TidaSqlExceptions.createException(4009);
	}

	@Override
	public void updateBinaryStream(final String columnLabel, final InputStream x)
			throws SQLException {
		checkClosed();

		throw TidaSqlExceptions.createException(4009);
	}

	@Override
	public void updateCharacterStream(final String columnLabel,
			final Reader reader) throws SQLException {
		checkClosed();

		throw TidaSqlExceptions.createException(4009);
	}

	@Override
	public void updateBlob(final int columnIndex, final InputStream inputStream)
			throws SQLException {
		checkClosed();

		throw TidaSqlExceptions.createException(4009);
	}

	@Override
	public void updateBlob(final String columnLabel,
			final InputStream inputStream) throws SQLException {
		checkClosed();

		throw TidaSqlExceptions.createException(4009);
	}

	@Override
	public void updateClob(final int columnIndex, final Reader reader)
			throws SQLException {
		checkClosed();

		throw TidaSqlExceptions.createException(4009);
	}

	@Override
	public void updateClob(final String columnLabel, final Reader reader)
			throws SQLException {
		checkClosed();

		throw TidaSqlExceptions.createException(4009);
	}

	@Override
	public void updateNClob(final int columnIndex, final Reader reader)
			throws SQLException {
		checkClosed();

		throw TidaSqlExceptions.createException(4009);
	}

	@Override
	public void updateNClob(final String columnLabel, final Reader reader)
			throws SQLException {
		checkClosed();

		throw TidaSqlExceptions.createException(4009);
	}

	@Override
	public String toString() {
		final Object[] curRow = handler.getLastResult();
		final String row = curRow == null ? null : Arrays.asList(curRow)
				.toString();

		return "[" + getClass().getSimpleName() + "] " + row + " from " + sql;
	}

	/**
	 * Gets the type of {@code this}.
	 * 
	 * @return the type of {@code this}
	 */
	public TidaResultSetType getResultSetType() {
		return handler.getResultSetType();
	}

	/**
	 * Gets the count-value, i.e. the amount of inserted rows if an insert-query
	 * was fired.
	 * 
	 * @return the count-value
	 */
	public Integer getCountValue() {
		return handler.getCountValue();
	}

	/**
	 * Gets the generated keys of the insert-query.
	 * 
	 * @return the generated keys
	 */
	public Integer[] getGeneratedKeys() {
		return handler.getGeneratedIds();
	}
}
