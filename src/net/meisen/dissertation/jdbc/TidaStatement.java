package net.meisen.dissertation.jdbc;

import java.io.InputStream;
import java.io.Reader;
import java.math.BigDecimal;
import java.net.URL;
import java.sql.Array;
import java.sql.Blob;
import java.sql.Clob;
import java.sql.Connection;
import java.sql.Date;
import java.sql.NClob;
import java.sql.ParameterMetaData;
import java.sql.PreparedStatement;
import java.sql.Ref;
import java.sql.ResultSet;
import java.sql.ResultSetMetaData;
import java.sql.RowId;
import java.sql.SQLException;
import java.sql.SQLWarning;
import java.sql.SQLXML;
import java.sql.Statement;
import java.sql.Time;
import java.sql.Timestamp;
import java.util.ArrayList;
import java.util.Calendar;
import java.util.List;
import java.util.concurrent.Callable;
import java.util.concurrent.ExecutionException;
import java.util.concurrent.ExecutorService;
import java.util.concurrent.Executors;
import java.util.concurrent.Future;
import java.util.concurrent.TimeUnit;
import java.util.concurrent.TimeoutException;

/**
 * The implementation of a {@code Statement} as well as an
 * {@code PreparedStatement}.
 * 
 * @author pmeisen
 * 
 */
public class TidaStatement extends BaseConnectionWrapper implements Statement,
		PreparedStatement {
	private boolean todoMarker;

	/**
	 * The enumeration is used to determine the type of the current
	 * {@code ResultSet}. The {@code currentResultSet} could have been returned
	 * by the statement, therefore responsibility of closing is given to the
	 * using instance, or it could be used within the statement. In the later
	 * case the {@code Statement} has the responsibility to handle the
	 * {@code ResultSet}.
	 * 
	 * @author pmeisen
	 * 
	 */
	protected enum CurrentResultSetType {
		/**
		 * The {@code currentResultSet} of the {@code Statement} was passed to a
		 * calling instance. Responsibility is therefore with the calling
		 * instance.
		 */
		RETURNED_AS_RESULT,
		/**
		 * The {@code currentResultSet} is used internally by the
		 * {@code Statement}. Responsibility of closing is thereby with the
		 * {@code Statement}.
		 */
		USED_BY_STATEMENT;
	}

	private final String sql;
	private final ExecutorService executor;

	private final int resultSetType;
	private final int resultSetConcurrency;
	private final int resultSetHoldability;
	private final int autoGeneratedKeys;
	private final int[] columnIndexes;
	private final String[] columnNames;

	private List<String> batch;
	private int queryTimeoutInMs;
	private TidaResultSet currentResultSet;
	private CurrentResultSetType currentResultSetType;

	/**
	 * Creating a {@code Statement} for the specified {@code connection} and the
	 * specified {@code sql}. The {@code Statement} will use the specified
	 * {@code resultSetType}, {@code resultSetConcurrency},
	 * {@code resultSetHoldability} and the {@code autoGeneratedKeys}.
	 * 
	 * @param connection
	 *            the connection used to fire the statement
	 * @param sql
	 *            the statement to be fired
	 * @param resultSetType
	 *            the type of the {@code ResultSet}, supports only
	 *            {@link ResultSet#TYPE_FORWARD_ONLY}
	 * @param resultSetConcurrency
	 *            the concurrency handling, supports only
	 *            {@link ResultSet#CONCUR_READ_ONLY}
	 * @param resultSetHoldability
	 *            the holdability, supports only
	 *            {@link ResultSet#CLOSE_CURSORS_AT_COMMIT} and
	 *            {@link ResultSet#HOLD_CURSORS_OVER_COMMIT}
	 * @param columnIndexes
	 *            the indexes of the columns to retrieve the key from, should be
	 *            empty or {@code null}
	 * 
	 * @throws SQLException
	 *             if the statement cannot be created
	 */
	public TidaStatement(final TidaConnection connection, final String sql,
			final int resultSetType, final int resultSetConcurrency,
			final int resultSetHoldability, final int[] columnIndexes)
			throws SQLException {
		this(connection, sql, resultSetType, resultSetConcurrency,
				resultSetHoldability, Statement.RETURN_GENERATED_KEYS);
	}

	/**
	 * Creating a {@code Statement} for the specified {@code connection} and the
	 * specified {@code sql}. The {@code Statement} will use the specified
	 * {@code resultSetType}, {@code resultSetConcurrency},
	 * {@code resultSetHoldability} and the {@code autoGeneratedKeys}.
	 * 
	 * @param connection
	 *            the connection used to fire the statement
	 * @param sql
	 *            the statement to be fired
	 * @param resultSetType
	 *            the type of the {@code ResultSet}, supports only
	 *            {@link ResultSet#TYPE_FORWARD_ONLY}
	 * @param resultSetConcurrency
	 *            the concurrency handling, supports only
	 *            {@link ResultSet#CONCUR_READ_ONLY}
	 * @param resultSetHoldability
	 *            the holdability, supports only
	 *            {@link ResultSet#CLOSE_CURSORS_AT_COMMIT} and
	 *            {@link ResultSet#HOLD_CURSORS_OVER_COMMIT}
	 * @param columnNames
	 *            the names of the columns to retrieve the key from, should be
	 *            empty or {@code null}
	 * 
	 * @throws SQLException
	 *             if the statement cannot be created
	 */
	public TidaStatement(final TidaConnection connection, final String sql,
			final int resultSetType, final int resultSetConcurrency,
			final int resultSetHoldability, final String[] columnNames)
			throws SQLException {
		this(connection, sql, resultSetType, resultSetConcurrency,
				resultSetHoldability, Statement.RETURN_GENERATED_KEYS);
	}

	/**
	 * Creating a {@code Statement} for the specified {@code connection} and the
	 * specified {@code sql}. The {@code Statement} will use the specified
	 * {@code resultSetType}, {@code resultSetConcurrency},
	 * {@code resultSetHoldability} and the {@code autoGeneratedKeys}.
	 * 
	 * @param connection
	 *            the connection used to fire the statement
	 * @param sql
	 *            the statement to be fired
	 * @param resultSetType
	 *            the type of the {@code ResultSet}, supports only
	 *            {@link ResultSet#TYPE_FORWARD_ONLY}
	 * @param resultSetConcurrency
	 *            the concurrency handling, supports only
	 *            {@link ResultSet#CONCUR_READ_ONLY}
	 * @param resultSetHoldability
	 *            the holdability, supports only
	 *            {@link ResultSet#CLOSE_CURSORS_AT_COMMIT} and
	 *            {@link ResultSet#HOLD_CURSORS_OVER_COMMIT}
	 * @param autoGeneratedKeys
	 *            the handling of generated keys, supports only
	 *            {@link Statement#NO_GENERATED_KEYS} and
	 *            {@link Statement#RETURN_GENERATED_KEYS}
	 * 
	 * @throws SQLException
	 *             if the statement cannot be created
	 */
	public TidaStatement(final TidaConnection connection, final String sql,
			final int resultSetType, final int resultSetConcurrency,
			final int resultSetHoldability, final int autoGeneratedKeys)
			throws SQLException {
		this(connection, sql, resultSetType, resultSetConcurrency,
				resultSetHoldability, autoGeneratedKeys, null, null);
	}

	/**
	 * Creating a {@code Statement} for the specified {@code connection} and the
	 * specified {@code sql}. The {@code Statement} will use the specified
	 * {@code resultSetType}, {@code resultSetConcurrency},
	 * {@code resultSetHoldability} and the {@code autoGeneratedKeys}.
	 * 
	 * @param connection
	 *            the connection used to fire the statement
	 * @param sql
	 *            the statement to be fired
	 * @param resultSetType
	 *            the type of the {@code ResultSet}, supports only
	 *            {@link ResultSet#TYPE_FORWARD_ONLY}
	 * @param resultSetConcurrency
	 *            the concurrency handling, supports only
	 *            {@link ResultSet#CONCUR_READ_ONLY}
	 * @param resultSetHoldability
	 *            the holdability, supports only
	 *            {@link ResultSet#CLOSE_CURSORS_AT_COMMIT} and
	 *            {@link ResultSet#HOLD_CURSORS_OVER_COMMIT}
	 * @param autoGeneratedKeys
	 *            the handling of generated keys, supports only
	 *            {@link Statement#NO_GENERATED_KEYS} and
	 *            {@link Statement#RETURN_GENERATED_KEYS}
	 * @param columnIndexes
	 *            the indexes of the columns to retrieve the key from, should be
	 *            empty or {@code null}
	 * @param columnNames
	 *            the names of the columns to retrieve the key from, should be
	 *            empty or {@code null}
	 * 
	 * @throws SQLException
	 *             if the statement cannot be created
	 */
	public TidaStatement(final TidaConnection connection, final String sql,
			final int resultSetType, final int resultSetConcurrency,
			final int resultSetHoldability, final int autoGeneratedKeys,
			final int[] columnIndexes, final String[] columnNames)
			throws SQLException {
		super(connection);

		// set defaults
		this.batch = new ArrayList<String>();
		this.queryTimeoutInMs = 0;
		this.currentResultSet = null;
		this.currentResultSetType = null;

		// set specified stuff
		this.resultSetType = resultSetType;
		this.resultSetConcurrency = resultSetConcurrency;
		this.resultSetHoldability = resultSetHoldability;
		this.autoGeneratedKeys = autoGeneratedKeys;
		this.columnIndexes = columnIndexes;
		this.columnNames = columnNames;

		this.sql = sql;
		this.executor = Executors.newFixedThreadPool(1);
	}

	@Override
	protected BaseConnectionWrapper getProtocolScope() {
		return this;
	}

	@Override
	protected boolean doCloseOnCommit() {
		return false;
	}

	@Override
	public void close() throws SQLException {
		if (isClosed()) {
			return;
		}

		// close any currentResultSet
		if (currentResultSet != null
				&& CurrentResultSetType.USED_BY_STATEMENT
						.equals(currentResultSetType)) {
			currentResultSet.close();
		}

		// close the rest
		super.close();
	}

	/**
	 * Checks if the connection is closed, if so an exception is thrown,
	 * otherwise nothing happens.
	 * 
	 * @throws SQLException
	 *             if the connection is closed
	 * 
	 * @see #isClosed()
	 */
	protected void checkClosed() throws SQLException {
		if (isClosed()) {
			throw TidaSqlExceptions.createException(3999);
		}
	}

	/**
	 * Executes the statement specified by the {@code sql}. Any
	 * {@code currentResultSet} will be closed if the
	 * {@code currentResultSetType} of {@code this} is different from
	 * {@link CurrentResultSetType#RETURNED_AS_RESULT}.<br/>
	 * <br/>
	 * The method ensures that the {@code TidaResultSetType} of the returning
	 * {@code ResultSet} is of the type specified by {@code type}. If the types
	 * do not match an exception is thrown. If {@code type} is equal to
	 * {@link TidaResultSetType#UNKNOWN}, every type is allowed to be returned.<br/>
	 * <br/>
	 * Furthermore, the method allows to specify the {@code columnIndexes} or
	 * {@code columnNames} to retrieve keys from. Nevertheless, the key is
	 * typically not available in any column, therefore if the generated keys
	 * should be returned it should just be done using
	 * {@link Statement#RETURN_GENERATED_KEYS} and passing {@code null} or an
	 * empty array for {@code columnIndexes} or/and {@code columnNames}.
	 * 
	 * @param sql
	 *            the statement to be fired
	 * @param type
	 *            the expected type of the {@code TidaResultSet}, can be
	 *            {@link TidaResultSetType#UNKNOWN} if nothing specific is
	 *            expected
	 * @param currentResultSetType
	 *            the type of the usage of the created {@code TidaResultSet}
	 * @param autoGeneratedKeys
	 *            one of {@link Statement#RETURN_GENERATED_KEYS} or
	 *            {@link Statement#NO_GENERATED_KEYS}
	 * @param columnIndexes
	 *            the indexes of the columns to retrieve the key from, should be
	 *            empty or {@code null}
	 * @param columnNames
	 *            the names of the columns to retrieve the key from, should be
	 *            empty or {@code null}
	 * 
	 * @return the created instance
	 * 
	 * @throws SQLException
	 *             if the {@code Statement} is closed, if the resulting type of
	 *             the {@code ResultSet} does not match the expectation, or if
	 *             any unsupported setting is used
	 */
	protected TidaResultSet execute(final String sql,
			final TidaResultSetType type,
			final CurrentResultSetType currentResultSetType,
			final int autoGeneratedKeys, final int[] columnIndexes,
			final String[] columnNames) throws SQLException {
		checkClosed();

		if (currentResultSet != null
				&& CurrentResultSetType.USED_BY_STATEMENT
						.equals(this.currentResultSetType)) {

			/*
			 * Close any currentResultSet, because it cannot be used anymore.
			 * The currentResultSet is only kept if the information was needed
			 * afterwards.
			 */
			currentResultSet.close();
			currentResultSet = null;
		}

		// get the sql to be used
		final String query = sql == null ? this.sql : sql;

		// create a thread to fire a query
		final Callable<TidaResultSet> executeTask = new Callable<TidaResultSet>() {

			@Override
			public TidaResultSet call() throws SQLException {
				return new TidaResultSet(TidaStatement.this, query, type,
						getResultSetType(), getResultSetConcurrency(),
						getResultSetHoldability(), autoGeneratedKeys,
						columnIndexes, columnNames);
			}
		};

		// run the query
		final Future<TidaResultSet> future = executor.submit(executeTask);
		final TidaResultSet resultSet;
		try {
			if (queryTimeoutInMs == 0) {
				resultSet = future.get();
			} else {
				resultSet = future.get(queryTimeoutInMs, TimeUnit.MILLISECONDS);
			}
		} catch (final InterruptedException e) {
			throw TidaSqlExceptions
					.createException(3006, query, e.getMessage());
		} catch (final ExecutionException e) {
			if (e.getCause() instanceof SQLException) {
				throw (SQLException) e.getCause();
			} else {
				throw (RuntimeException) e.getCause();
			}
		} catch (final TimeoutException e) {
			future.cancel(true);
			throw TidaSqlExceptions.createException(3005, query, ""
					+ getQueryTimeout());
		}

		// if the generated keys are needed than keep those
		this.currentResultSet = resultSet;
		this.currentResultSetType = currentResultSetType;

		return resultSet;
	}

	@Override
	public TidaResultSet executeQuery() throws SQLException {
		return executeQuery(null);
	}

	@Override
	public TidaResultSet executeQuery(final String sql) throws SQLException {
		return executeQuery(sql, autoGeneratedKeys, columnIndexes, columnNames);
	}

	/**
	 * Executes the specified {@code sql} statement, which has to be of the type
	 * {@link TidaResultSetType#QUERY}.
	 * 
	 * @param sql
	 *            the statement to be executed
	 * @param autoGeneratedKeys
	 *            definition of auto-generated keys should be returned, see
	 *            {@link #TidaStatement(TidaConnection, String, int, int, int, int)}
	 *            for supported settings
	 * @param columnIndexes
	 *            the column indexes used to retrieve the key, should be empty
	 *            or {@code null}
	 * @param columnNames
	 *            the column names used to retrieve the key, should be empty or
	 *            {@code null}
	 * 
	 * @return the {@code ResultSet}
	 * 
	 * @throws SQLException
	 *             if the result cannot be retrieved
	 */
	protected TidaResultSet executeQuery(final String sql,
			final int autoGeneratedKeys, final int[] columnIndexes,
			final String[] columnNames) throws SQLException {
		final TidaResultSet resultSet = execute(sql, TidaResultSetType.QUERY,
				CurrentResultSetType.RETURNED_AS_RESULT, autoGeneratedKeys,
				columnIndexes, columnNames);
		return resultSet;
	}

	@Override
	public boolean execute() throws SQLException {
		return execute(null);
	}

	@Override
	public boolean execute(final String sql) throws SQLException {
		return execute(sql, autoGeneratedKeys, null, null);
	}

	@Override
	public boolean execute(final String sql, final int autoGeneratedKeys)
			throws SQLException {
		return execute(sql, autoGeneratedKeys, null, null);
	}

	@Override
	public boolean execute(final String sql, final int[] columnIndexes)
			throws SQLException {
		return execute(sql, Statement.RETURN_GENERATED_KEYS, columnIndexes,
				null);
	}

	@Override
	public boolean execute(final String sql, final String[] columnNames)
			throws SQLException {
		return execute(sql, Statement.RETURN_GENERATED_KEYS, null, columnNames);
	}

	/**
	 * Executes the specified {@code sql} statement, which has to be of the type
	 * {@link TidaResultSetType#QUERY} or {@link TidaResultSetType#MODIFY}.
	 * 
	 * @param sql
	 *            the statement to be executed
	 * @param autoGeneratedKeys
	 *            definition of auto-generated keys should be returned, see
	 *            {@link #TidaStatement(TidaConnection, String, int, int, int, int)}
	 *            for supported settings
	 * @param columnIndexes
	 *            the column indexes used to retrieve the key, should be empty
	 *            or {@code null}
	 * @param columnNames
	 *            the column names used to retrieve the key, should be empty or
	 *            {@code null}
	 * 
	 * @return {@code true} if it's a query statement, otherwise {@code false}
	 *         (i.e. it's a modify statement)
	 * 
	 * @throws SQLException
	 *             if the result cannot be retrieved
	 */
	protected boolean execute(final String sql, final int autoGeneratedKeys,
			final int[] columnIndexes, final String[] columnNames)
			throws SQLException {
		final TidaResultSet resultSet = execute(sql, TidaResultSetType.UNKNOWN,
				CurrentResultSetType.USED_BY_STATEMENT, autoGeneratedKeys,
				columnIndexes, columnNames);

		// keep the currentResultSet
		return TidaResultSetType.QUERY.equals(resultSet.getResultSetType());
	}

	@Override
	public int executeUpdate() throws SQLException {
		return executeUpdate(null);
	}

	@Override
	public int executeUpdate(final String sql) throws SQLException {
		return executeUpdate(sql, autoGeneratedKeys, columnIndexes, columnNames);
	}

	@Override
	public int executeUpdate(final String sql, final int autoGeneratedKeys)
			throws SQLException {
		return executeUpdate(sql, autoGeneratedKeys, null, null);
	}

	@Override
	public int executeUpdate(final String sql, final int[] columnIndexes)
			throws SQLException {
		return executeUpdate(sql, Statement.RETURN_GENERATED_KEYS,
				columnIndexes, null);
	}

	@Override
	public int executeUpdate(final String sql, final String[] columnNames)
			throws SQLException {
		return executeUpdate(sql, Statement.RETURN_GENERATED_KEYS, null,
				columnNames);
	}

	/**
	 * Executes the specified {@code sql} statement, which has to be of the type
	 * {@link TidaResultSetType#MODIFY}.
	 * 
	 * @param sql
	 *            the statement to be executed
	 * @param autoGeneratedKeys
	 *            definition of auto-generated keys should be returned, see
	 *            {@link #TidaStatement(TidaConnection, String, int, int, int, int)}
	 *            for supported settings
	 * @param columnIndexes
	 *            the column indexes used to retrieve the key, should be empty
	 *            or {@code null}
	 * @param columnNames
	 *            the column names used to retrieve the key, should be empty or
	 *            {@code null}
	 * 
	 * @return typically the amount of records modified, but might have a
	 *         different meaning for the specified {@code sql} statement
	 * 
	 * @throws SQLException
	 *             if the result cannot be retrieved
	 */
	protected int executeUpdate(final String sql, final int autoGeneratedKeys,
			final int[] columnIndexes, final String[] columnNames)
			throws SQLException {
		final TidaResultSet resultSet = execute(sql, TidaResultSetType.MODIFY,
				CurrentResultSetType.USED_BY_STATEMENT, autoGeneratedKeys,
				columnIndexes, columnNames);

		return resultSet.getCountValue();
	}

	@Override
	public int[] executeBatch() throws SQLException {
		checkClosed();

		final int[] res = new int[batch.size()];
		for (int i = 0; i < batch.size(); i++) {
			res[i] = executeUpdate(sql);
		}

		return res;
	}

	@Override
	public int getMaxFieldSize() throws SQLException {
		return 0;
	}

	@Override
	public void setMaxFieldSize(final int max) throws SQLException {
		// ignored
	}

	@Override
	public int getMaxRows() throws SQLException {
		return Integer.MAX_VALUE;
	}

	@Override
	public void setMaxRows(final int max) throws SQLException {
		// ignored
	}

	@Override
	public void setEscapeProcessing(final boolean enable) throws SQLException {
		// ignored
	}

	@Override
	public int getQueryTimeout() throws SQLException {
		checkClosed();

		return queryTimeoutInMs / 1000;
	}

	/**
	 * Sets the time-out in milliseconds.
	 * 
	 * @param milliseconds
	 *            the time-out value to be used
	 * 
	 * @throws SQLException
	 *             if the statement is closed
	 */
	public void setQueryTimeoutInMs(final int milliseconds) throws SQLException {
		if (milliseconds < 0) {
			throw TidaSqlExceptions.createException(3004, "" + milliseconds);
		}

		this.queryTimeoutInMs = milliseconds;
	}

	@Override
	public void setQueryTimeout(final int seconds) throws SQLException {
		setQueryTimeoutInMs(seconds * 1000);
	}

	@Override
	public void cancel() throws SQLException {
		executor.shutdownNow();
	}

	@Override
	public SQLWarning getWarnings() throws SQLException {
		checkClosed();

		return new SQLWarning();
	}

	@Override
	public void clearWarnings() throws SQLException {
		checkClosed();
	}

	@Override
	public void setCursorName(final String name) throws SQLException {
		// no-op method
	}

	@Override
	public ResultSet getResultSet() throws SQLException {
		checkClosed();

		if (this.currentResultSet == null) {
			return null;
		} else if (!TidaResultSetType.QUERY.equals(currentResultSet
				.getResultSetType())) {
			return null;
		} else if (CurrentResultSetType.RETURNED_AS_RESULT
				.equals(currentResultSetType)) {
			return null;
		} else {
			this.currentResultSetType = CurrentResultSetType.RETURNED_AS_RESULT;

			// make sure it cannot be retrieved a second time
			return currentResultSet;
		}
	}

	@Override
	public int getUpdateCount() throws SQLException {
		checkClosed();

		if (currentResultSet == null) {
			return -1;
		} else if (!TidaResultSetType.MODIFY.equals(currentResultSet
				.getResultSetType())) {
			return -1;
		} else {
			final Integer count = currentResultSet.getCountValue();

			// check if we have a count
			if (count == null) {
				return -1;
			} else {
				return count;
			}
		}
	}

	@Override
	public boolean getMoreResults() throws SQLException {
		return false;
	}

	@Override
	public void setFetchDirection(final int direction) throws SQLException {
		checkClosed();

		if (direction != ResultSet.FETCH_FORWARD) {
			throw TidaSqlExceptions.createNotSupportedException(3000, ""
					+ direction);
		}
	}

	@Override
	public int getFetchDirection() throws SQLException {
		checkClosed();

		return ResultSet.FETCH_FORWARD;
	}

	@Override
	public void setFetchSize(final int rows) throws SQLException {
		checkClosed();

		if (rows > 1) {
			throw TidaSqlExceptions
					.createNotSupportedException(3001, "" + rows);
		} else if (rows < 0) {
			throw TidaSqlExceptions.createException(3002, "" + rows);
		}
	}

	@Override
	public int getFetchSize() throws SQLException {
		checkClosed();

		return 1;
	}

	@Override
	public int getResultSetConcurrency() throws SQLException {
		return resultSetConcurrency;
	}

	@Override
	public int getResultSetType() throws SQLException {
		return resultSetType;
	}

	@Override
	public int getResultSetHoldability() throws SQLException {
		return resultSetHoldability;
	}

	@Override
	public void addBatch(final String sql) throws SQLException {
		batch.add(sql);
	}

	@Override
	public void clearBatch() throws SQLException {
		batch.clear();
	}

	@Override
	public Connection getConnection() throws SQLException {
		return (Connection) getParent();
	}

	@Override
	public boolean getMoreResults(final int current) throws SQLException {
		return false;
	}

	@Override
	public ResultSet getGeneratedKeys() throws SQLException {
		if (currentResultSet == null) {
			return null;
		} else {
			return new IntResultSet(currentResultSet.getGeneratedKeys(), this);
		}
	}

	@Override
	public void setPoolable(final boolean poolable) throws SQLException {
		if (poolable) {
			throw TidaSqlExceptions.createNotSupportedException(3003);
		}
	}

	@Override
	public boolean isPoolable() throws SQLException {
		return false;
	}

	@Override
	public void setNull(final int parameterIndex, final int sqlType)
			throws SQLException {
		// TODO Auto-generated method stub

	}

	@Override
	public void setBoolean(final int parameterIndex, final boolean x)
			throws SQLException {
		// TODO Auto-generated method stub

	}

	@Override
	public void setByte(final int parameterIndex, final byte x)
			throws SQLException {
		// TODO Auto-generated method stub

	}

	@Override
	public void setShort(final int parameterIndex, final short x)
			throws SQLException {
		// TODO Auto-generated method stub
	}

	@Override
	public void setInt(final int parameterIndex, final int x)
			throws SQLException {
		// TODO Auto-generated method stub

	}

	@Override
	public void setLong(final int parameterIndex, final long x)
			throws SQLException {
		// TODO Auto-generated method stub

	}

	@Override
	public void setFloat(final int parameterIndex, final float x)
			throws SQLException {
		// TODO Auto-generated method stub

	}

	@Override
	public void setDouble(final int parameterIndex, final double x)
			throws SQLException {
		// TODO Auto-generated method stub

	}

	@Override
	public void setBigDecimal(final int parameterIndex, final BigDecimal x)
			throws SQLException {
		// TODO Auto-generated method stub

	}

	@Override
	public void setString(final int parameterIndex, final String x)
			throws SQLException {
		// TODO Auto-generated method stub

	}

	@Override
	public void setBytes(final int parameterIndex, final byte[] x)
			throws SQLException {
		// TODO Auto-generated method stub

	}

	@Override
	public void setDate(final int parameterIndex, final Date x)
			throws SQLException {
		// TODO Auto-generated method stub

	}

	@Override
	public void setTime(final int parameterIndex, final Time x)
			throws SQLException {
		// TODO Auto-generated method stub

	}

	@Override
	public void setTimestamp(final int parameterIndex, final Timestamp x)
			throws SQLException {
		// TODO Auto-generated method stub

	}

	@Override
	public void setAsciiStream(final int parameterIndex, final InputStream x,
			final int length) throws SQLException {
		// TODO Auto-generated method stub

	}

	@Override
	@Deprecated
	public void setUnicodeStream(final int parameterIndex, final InputStream x,
			final int length) throws SQLException {
		// TODO Auto-generated method stub

	}

	@Override
	public void setBinaryStream(final int parameterIndex, final InputStream x,
			final int length) throws SQLException {
		// TODO Auto-generated method stub

	}

	@Override
	public void clearParameters() throws SQLException {
		// TODO Auto-generated method stub

	}

	@Override
	public void setObject(final int parameterIndex, final Object x,
			final int targetSqlType) throws SQLException {
		// TODO Auto-generated method stub

	}

	@Override
	public void setObject(final int parameterIndex, final Object x)
			throws SQLException {
		// TODO Auto-generated method stub

	}

	@Override
	public void addBatch() throws SQLException {
		// TODO Auto-generated method stub

	}

	@Override
	public void setCharacterStream(final int parameterIndex,
			final Reader reader, final int length) throws SQLException {
		// TODO Auto-generated method stub

	}

	@Override
	public void setRef(final int parameterIndex, final Ref x)
			throws SQLException {
		// TODO Auto-generated method stub

	}

	@Override
	public void setBlob(final int parameterIndex, final Blob x)
			throws SQLException {
		// TODO Auto-generated method stub

	}

	@Override
	public void setClob(final int parameterIndex, final Clob x)
			throws SQLException {
		// TODO Auto-generated method stub

	}

	@Override
	public void setArray(final int parameterIndex, final Array x)
			throws SQLException {
		// TODO Auto-generated method stub

	}

	@Override
	public ResultSetMetaData getMetaData() throws SQLException {
		if (currentResultSet == null) {
			return null;
		} else {
			return currentResultSet.getMetaData();
		}
	}

	@Override
	public void setDate(final int parameterIndex, Date x, final Calendar cal)
			throws SQLException {
		// TODO Auto-generated method stub

	}

	@Override
	public void setTime(final int parameterIndex, final Time x,
			final Calendar cal) throws SQLException {
		// TODO Auto-generated method stub

	}

	@Override
	public void setTimestamp(final int parameterIndex, final Timestamp x,
			final Calendar cal) throws SQLException {
		// TODO Auto-generated method stub

	}

	@Override
	public void setNull(final int parameterIndex, final int sqlType,
			final String typeName) throws SQLException {
		// TODO Auto-generated method stub

	}

	@Override
	public void setURL(final int parameterIndex, final URL x)
			throws SQLException {
		// TODO Auto-generated method stub

	}

	@Override
	public ParameterMetaData getParameterMetaData() throws SQLException {
		// TODO Auto-generated method stub
		return null;
	}

	@Override
	public void setRowId(final int parameterIndex, final RowId x)
			throws SQLException {
		// TODO Auto-generated method stub

	}

	@Override
	public void setNString(final int parameterIndex, final String value)
			throws SQLException {
		// TODO Auto-generated method stub

	}

	@Override
	public void setNCharacterStream(final int parameterIndex,
			final Reader value, final long length) throws SQLException {
		// TODO Auto-generated method stub

	}

	@Override
	public void setNClob(final int parameterIndex, final NClob value)
			throws SQLException {
		// TODO Auto-generated method stub

	}

	@Override
	public void setClob(final int parameterIndex, final Reader reader,
			final long length) throws SQLException {
		// TODO Auto-generated method stub

	}

	@Override
	public void setBlob(final int parameterIndex,
			final InputStream inputStream, final long length)
			throws SQLException {
		// TODO Auto-generated method stub

	}

	@Override
	public void setNClob(final int parameterIndex, final Reader reader,
			final long length) throws SQLException {
		// TODO Auto-generated method stub

	}

	@Override
	public void setSQLXML(final int parameterIndex, final SQLXML xmlObject)
			throws SQLException {
		// TODO Auto-generated method stub

	}

	@Override
	public void setObject(final int parameterIndex, final Object x,
			final int targetSqlType, final int scaleOrLength)
			throws SQLException {
		// TODO Auto-generated method stub

	}

	@Override
	public void setAsciiStream(final int parameterIndex, final InputStream x,
			final long length) throws SQLException {
		// TODO Auto-generated method stub

	}

	@Override
	public void setBinaryStream(final int parameterIndex, final InputStream x,
			final long length) throws SQLException {
		// TODO Auto-generated method stub

	}

	@Override
	public void setCharacterStream(final int parameterIndex,
			final Reader reader, final long length) throws SQLException {
		// TODO Auto-generated method stub

	}

	@Override
	public void setAsciiStream(final int parameterIndex, final InputStream x)
			throws SQLException {
		// TODO Auto-generated method stub

	}

	@Override
	public void setBinaryStream(final int parameterIndex, final InputStream x)
			throws SQLException {
		// TODO Auto-generated method stub

	}

	@Override
	public void setCharacterStream(final int parameterIndex, final Reader reader)
			throws SQLException {
		// TODO Auto-generated method stub

	}

	@Override
	public void setNCharacterStream(final int parameterIndex, final Reader value)
			throws SQLException {
		// TODO Auto-generated method stub

	}

	@Override
	public void setClob(final int parameterIndex, final Reader reader)
			throws SQLException {
		// TODO Auto-generated method stub

	}

	@Override
	public void setBlob(final int parameterIndex, final InputStream inputStream)
			throws SQLException {
		// TODO Auto-generated method stub

	}

	@Override
	public void setNClob(final int parameterIndex, final Reader reader)
			throws SQLException {
		// TODO Auto-generated method stub

	}

	@Override
	public String toString() {
		return "[" + getClass().getSimpleName() + "] " + sql;
	}
}
