package net.meisen.dissertation.jdbc;

import java.io.InputStream;
import java.io.Reader;
import java.math.BigDecimal;
import java.net.URL;
import java.sql.Array;
import java.sql.Blob;
import java.sql.Clob;
import java.sql.Connection;
import java.sql.Date;
import java.sql.NClob;
import java.sql.ParameterMetaData;
import java.sql.PreparedStatement;
import java.sql.Ref;
import java.sql.ResultSet;
import java.sql.ResultSetMetaData;
import java.sql.RowId;
import java.sql.SQLException;
import java.sql.SQLWarning;
import java.sql.SQLXML;
import java.sql.Statement;
import java.sql.Time;
import java.sql.Timestamp;
import java.util.ArrayList;
import java.util.Calendar;
import java.util.List;
import java.util.concurrent.Callable;
import java.util.concurrent.ExecutionException;
import java.util.concurrent.ExecutorService;
import java.util.concurrent.Executors;
import java.util.concurrent.Future;
import java.util.concurrent.TimeUnit;
import java.util.concurrent.TimeoutException;

public class TidaStatement extends BaseConnectionWrapper implements Statement,
		PreparedStatement {

	private final String sql;
	private final ExecutorService executor;

	private final int resultSetType;
	private final int resultSetConcurrency;
	private final int resultSetHoldability;

	private List<String> batch;
	private int queryTimeoutInMs;
	private TidaResultSet currentResultSet;

	public TidaStatement(final TidaConnection connection, final String sql,
			final int resultSetType, final int resultSetConcurrency,
			final int resultSetHoldability, final int autoGeneratedKeys)
			throws SQLException {
		this(connection, sql, resultSetType, resultSetConcurrency,
				resultSetHoldability);
	}

	public TidaStatement(final TidaConnection connection, final String sql,
			final int resultSetType, final int resultSetConcurrency,
			final int resultSetHoldability, final int[] columnIndexes)
			throws SQLException {
		this(connection, sql, resultSetType, resultSetConcurrency,
				resultSetHoldability);
	}

	public TidaStatement(final TidaConnection connection, final String sql,
			final int resultSetType, final int resultSetConcurrency,
			final int resultSetHoldability, final String[] columnNames)
			throws SQLException {
		this(connection, sql, resultSetType, resultSetConcurrency,
				resultSetHoldability);
	}

	public TidaStatement(final TidaConnection connection, final String sql,
			final int resultSetType, final int resultSetConcurrency,
			final int resultSetHoldability) throws SQLException {
		super(connection);

		// set defaults
		this.batch = new ArrayList<String>();
		this.queryTimeoutInMs = 0;
		this.currentResultSet = null;

		// set specified stuff
		this.resultSetType = resultSetType;
		this.resultSetConcurrency = resultSetConcurrency;
		this.resultSetHoldability = resultSetHoldability;

		this.sql = sql;
		this.executor = Executors.newFixedThreadPool(1);
	}

	@Override
	protected BaseConnectionWrapper getProtocolScope() {
		return this;
	}

	@Override
	protected boolean doCloseOnCommit() {
		return false;
	}

	@Override
	public void close() throws SQLException {
		if (isClosed()) {
			return;
		}

		// close any currentResultSet
		if (currentResultSet != null) {
			currentResultSet.close();
		}

		// close the rest
		super.close();
	}

	/**
	 * Checks if the connection is closed, if so an exception is thrown,
	 * otherwise nothing happens.
	 * 
	 * @throws SQLException
	 *             if the connection is closed
	 * 
	 * @see #isClosed()
	 */
	protected void checkClosed() throws SQLException {
		if (isClosed()) {
			throw TidaSqlExceptions.createException(3999);
		}
	}

	protected TidaResultSet execute(final String sql,
			final TidaResultSetType type, final int autoGeneratedKeys,
			final int[] columnIndexes, final String[] columnNames)
			throws SQLException {
		checkClosed();

		if (currentResultSet != null) {

			/*
			 * Close any currentResultSet, because it cannot be used anymore.
			 * The currentResultSet is only kept if the information was needed
			 * afterwards.
			 */
			currentResultSet.close();
			currentResultSet = null;
		}

		// get the sql to be used
		final String query = sql == null ? this.sql : sql;

		// create a thread to fire a query
		final Callable<TidaResultSet> executeTask = new Callable<TidaResultSet>() {

			@Override
			public TidaResultSet call() throws SQLException {
				return new TidaResultSet(TidaStatement.this, query, type,
						getResultSetType(), getResultSetConcurrency(),
						getResultSetHoldability(), autoGeneratedKeys,
						columnIndexes, columnNames);
			}
		};

		// run the query
		final Future<TidaResultSet> future = executor.submit(executeTask);
		final TidaResultSet resultSet;
		try {
			if (queryTimeoutInMs == 0) {
				resultSet = future.get();
			} else {
				resultSet = future.get(queryTimeoutInMs, TimeUnit.MILLISECONDS);
			}
		} catch (final InterruptedException e) {
			throw TidaSqlExceptions
					.createException(3006, query, e.getMessage());
		} catch (final ExecutionException e) {
			if (e.getCause() instanceof SQLException) {
				throw (SQLException) e.getCause();
			} else {
				throw (RuntimeException) e.getCause();
			}
		} catch (final TimeoutException e) {
			future.cancel(true);
			throw TidaSqlExceptions.createException(3005, query, ""
					+ getQueryTimeout());
		}

		// if the generated keys are needed than keep those
		if (autoGeneratedKeys == Statement.RETURN_GENERATED_KEYS) {
			currentResultSet = resultSet;
		}

		return resultSet;
	}

	@Override
	public TidaResultSet executeQuery() throws SQLException {
		return executeQuery(null);
	}

	@Override
	public TidaResultSet executeQuery(final String sql) throws SQLException {
		return executeQuery(sql, Statement.NO_GENERATED_KEYS, null, null);
	}

	protected TidaResultSet executeQuery(final String sql,
			final int autoGeneratedKeys, final int[] columnIndexes,
			final String[] columnNames) throws SQLException {
		final TidaResultSet resultSet = execute(sql, TidaResultSetType.QUERY,
				Statement.NO_GENERATED_KEYS, columnIndexes, columnNames);
		return resultSet;
	}

	@Override
	public boolean execute() throws SQLException {
		return execute(null);
	}

	@Override
	public boolean execute(final String sql) throws SQLException {
		return execute(sql, Statement.NO_GENERATED_KEYS, null, null);
	}

	@Override
	public boolean execute(final String sql, final int autoGeneratedKeys)
			throws SQLException {
		return execute(sql, autoGeneratedKeys, null, null);
	}

	@Override
	public boolean execute(final String sql, final int[] columnIndexes)
			throws SQLException {
		return execute(sql, Statement.RETURN_GENERATED_KEYS, columnIndexes,
				null);
	}

	@Override
	public boolean execute(final String sql, final String[] columnNames)
			throws SQLException {
		return execute(sql, Statement.RETURN_GENERATED_KEYS, null, columnNames);
	}

	protected boolean execute(final String sql, final int autoGeneratedKeys,
			final int[] columnIndexes, final String[] columnNames)
			throws SQLException {
		final TidaResultSet resultSet = execute(sql, TidaResultSetType.UNKNOWN,
				autoGeneratedKeys, columnIndexes, columnNames);

		// keep the currentResultSet
		this.currentResultSet = resultSet;
		return TidaResultSetType.QUERY.equals(resultSet.getResultSetType());
	}

	@Override
	public int executeUpdate() throws SQLException {
		return executeUpdate(null);
	}

	@Override
	public int executeUpdate(final String sql) throws SQLException {
		return executeUpdate(sql, Statement.NO_GENERATED_KEYS, null, null);
	}

	@Override
	public int executeUpdate(final String sql, final int autoGeneratedKeys)
			throws SQLException {
		return executeUpdate(sql, autoGeneratedKeys, null, null);
	}

	@Override
	public int executeUpdate(final String sql, final int[] columnIndexes)
			throws SQLException {
		return executeUpdate(sql, Statement.RETURN_GENERATED_KEYS,
				columnIndexes, null);
	}

	@Override
	public int executeUpdate(final String sql, final String[] columnNames)
			throws SQLException {
		return executeUpdate(sql, Statement.RETURN_GENERATED_KEYS, null,
				columnNames);
	}

	protected int executeUpdate(final String sql, final int autoGeneratedKeys,
			final int[] columnIndexes, final String[] columnNames)
			throws SQLException {
		final TidaResultSet resultSet = execute(sql, TidaResultSetType.MODIFY,
				autoGeneratedKeys, columnIndexes, columnNames);

		return resultSet.getCountValue();
	}

	@Override
	public int[] executeBatch() throws SQLException {
		checkClosed();

		final int[] res = new int[batch.size()];
		for (int i = 0; i < batch.size(); i++) {
			res[i] = executeUpdate(sql);
		}

		return res;
	}

	@Override
	public int getMaxFieldSize() throws SQLException {
		return 0;
	}

	@Override
	public void setMaxFieldSize(final int max) throws SQLException {
		// ignored
	}

	@Override
	public int getMaxRows() throws SQLException {
		return Integer.MAX_VALUE;
	}

	@Override
	public void setMaxRows(final int max) throws SQLException {
		// ignored
	}

	@Override
	public void setEscapeProcessing(final boolean enable) throws SQLException {
		// ignored
	}

	@Override
	public int getQueryTimeout() throws SQLException {
		checkClosed();

		return queryTimeoutInMs / 1000;
	}

	/**
	 * Sets the time-out in milliseconds.
	 * 
	 * @param milliseconds
	 *            the time-out value to be used
	 * 
	 * @throws SQLException
	 *             if the statement is closed
	 */
	public void setQueryTimeoutInMs(final int milliseconds) throws SQLException {
		if (milliseconds < 0) {
			throw TidaSqlExceptions.createException(3004, "" + milliseconds);
		}

		this.queryTimeoutInMs = milliseconds;
	}

	@Override
	public void setQueryTimeout(final int seconds) throws SQLException {
		setQueryTimeoutInMs(seconds * 1000);
	}

	@Override
	public void cancel() throws SQLException {
		executor.shutdownNow();
	}

	@Override
	public SQLWarning getWarnings() throws SQLException {
		checkClosed();

		return new SQLWarning();
	}

	@Override
	public void clearWarnings() throws SQLException {
		checkClosed();
	}

	@Override
	public void setCursorName(final String name) throws SQLException {
		// no-op method
	}

	@Override
	public ResultSet getResultSet() throws SQLException {
		checkClosed();

		if (this.currentResultSet == null) {
			return null;
		} else if (!TidaResultSetType.QUERY.equals(currentResultSet
				.getResultSetType())) {
			return null;
		} else {
			final TidaResultSet resultSet = currentResultSet;

			// make sure it cannot be retrieved a second time
			this.currentResultSet = null;
			return resultSet;
		}
	}

	@Override
	public int getUpdateCount() throws SQLException {
		checkClosed();

		if (currentResultSet == null) {
			return -1;
		} else if (!TidaResultSetType.MODIFY.equals(currentResultSet
				.getResultSetType())) {
			return -1;
		} else {
			final Integer count = currentResultSet.getCountValue();
			currentResultSet.close();
			currentResultSet = null;

			// check if we have a count
			if (count == null) {
				return -1;
			} else {
				return count;
			}
		}
	}

	@Override
	public boolean getMoreResults() throws SQLException {
		return false;
	}

	@Override
	public void setFetchDirection(final int direction) throws SQLException {
		checkClosed();

		if (direction != ResultSet.FETCH_FORWARD) {
			throw TidaSqlExceptions.createNotSupportedException(3000, ""
					+ direction);
		}
	}

	@Override
	public int getFetchDirection() throws SQLException {
		checkClosed();

		return ResultSet.FETCH_FORWARD;
	}

	@Override
	public void setFetchSize(final int rows) throws SQLException {
		checkClosed();

		if (rows > 1) {
			throw TidaSqlExceptions
					.createNotSupportedException(3001, "" + rows);
		} else if (rows < 0) {
			throw TidaSqlExceptions.createException(3002, "" + rows);
		}
	}

	@Override
	public int getFetchSize() throws SQLException {
		checkClosed();

		return 1;
	}

	@Override
	public int getResultSetConcurrency() throws SQLException {
		return resultSetConcurrency;
	}

	@Override
	public int getResultSetType() throws SQLException {
		return resultSetType;
	}

	@Override
	public int getResultSetHoldability() throws SQLException {
		return resultSetHoldability;
	}

	@Override
	public void addBatch(final String sql) throws SQLException {
		batch.add(sql);
	}

	@Override
	public void clearBatch() throws SQLException {
		batch.clear();
	}

	@Override
	public Connection getConnection() throws SQLException {
		return (Connection) getParent();
	}

	@Override
	public boolean getMoreResults(final int current) throws SQLException {
		return false;
	}

	@Override
	public ResultSet getGeneratedKeys() throws SQLException {
		return new IntResultSet(currentResultSet.getGeneratedKeys(), this);
	}

	@Override
	public void setPoolable(final boolean poolable) throws SQLException {
		if (poolable) {
			throw TidaSqlExceptions.createNotSupportedException(3003);
		}
	}

	@Override
	public boolean isPoolable() throws SQLException {
		return false;
	}

	@Override
	public void setNull(final int parameterIndex, final int sqlType)
			throws SQLException {
		// TODO Auto-generated method stub

	}

	@Override
	public void setBoolean(final int parameterIndex, final boolean x)
			throws SQLException {
		// TODO Auto-generated method stub

	}

	@Override
	public void setByte(final int parameterIndex, final byte x)
			throws SQLException {
		// TODO Auto-generated method stub

	}

	@Override
	public void setShort(final int parameterIndex, final short x)
			throws SQLException {
		// TODO Auto-generated method stub
	}

	@Override
	public void setInt(final int parameterIndex, final int x)
			throws SQLException {
		// TODO Auto-generated method stub

	}

	@Override
	public void setLong(final int parameterIndex, final long x)
			throws SQLException {
		// TODO Auto-generated method stub

	}

	@Override
	public void setFloat(final int parameterIndex, final float x)
			throws SQLException {
		// TODO Auto-generated method stub

	}

	@Override
	public void setDouble(final int parameterIndex, final double x)
			throws SQLException {
		// TODO Auto-generated method stub

	}

	@Override
	public void setBigDecimal(final int parameterIndex, final BigDecimal x)
			throws SQLException {
		// TODO Auto-generated method stub

	}

	@Override
	public void setString(final int parameterIndex, final String x)
			throws SQLException {
		// TODO Auto-generated method stub

	}

	@Override
	public void setBytes(final int parameterIndex, final byte[] x)
			throws SQLException {
		// TODO Auto-generated method stub

	}

	@Override
	public void setDate(final int parameterIndex, final Date x)
			throws SQLException {
		// TODO Auto-generated method stub

	}

	@Override
	public void setTime(final int parameterIndex, final Time x)
			throws SQLException {
		// TODO Auto-generated method stub

	}

	@Override
	public void setTimestamp(final int parameterIndex, final Timestamp x)
			throws SQLException {
		// TODO Auto-generated method stub

	}

	@Override
	public void setAsciiStream(final int parameterIndex, final InputStream x,
			final int length) throws SQLException {
		// TODO Auto-generated method stub

	}

	@Override
	public void setUnicodeStream(final int parameterIndex, final InputStream x,
			final int length) throws SQLException {
		// TODO Auto-generated method stub

	}

	@Override
	public void setBinaryStream(final int parameterIndex, final InputStream x,
			final int length) throws SQLException {
		// TODO Auto-generated method stub

	}

	@Override
	public void clearParameters() throws SQLException {
		// TODO Auto-generated method stub

	}

	@Override
	public void setObject(final int parameterIndex, final Object x,
			final int targetSqlType) throws SQLException {
		// TODO Auto-generated method stub

	}

	@Override
	public void setObject(final int parameterIndex, final Object x)
			throws SQLException {
		// TODO Auto-generated method stub

	}

	@Override
	public void addBatch() throws SQLException {
		// TODO Auto-generated method stub

	}

	@Override
	public void setCharacterStream(final int parameterIndex,
			final Reader reader, final int length) throws SQLException {
		// TODO Auto-generated method stub

	}

	@Override
	public void setRef(final int parameterIndex, final Ref x)
			throws SQLException {
		// TODO Auto-generated method stub

	}

	@Override
	public void setBlob(final int parameterIndex, final Blob x)
			throws SQLException {
		// TODO Auto-generated method stub

	}

	@Override
	public void setClob(final int parameterIndex, final Clob x)
			throws SQLException {
		// TODO Auto-generated method stub

	}

	@Override
	public void setArray(final int parameterIndex, final Array x)
			throws SQLException {
		// TODO Auto-generated method stub

	}

	@Override
	public ResultSetMetaData getMetaData() throws SQLException {
		if (currentResultSet == null) {
			return null;
		} else {
			return currentResultSet.getMetaData();
		}
	}

	@Override
	public void setDate(final int parameterIndex, Date x, final Calendar cal)
			throws SQLException {
		// TODO Auto-generated method stub

	}

	@Override
	public void setTime(final int parameterIndex, final Time x,
			final Calendar cal) throws SQLException {
		// TODO Auto-generated method stub

	}

	@Override
	public void setTimestamp(final int parameterIndex, final Timestamp x,
			final Calendar cal) throws SQLException {
		// TODO Auto-generated method stub

	}

	@Override
	public void setNull(final int parameterIndex, final int sqlType,
			final String typeName) throws SQLException {
		// TODO Auto-generated method stub

	}

	@Override
	public void setURL(final int parameterIndex, final URL x)
			throws SQLException {
		// TODO Auto-generated method stub

	}

	@Override
	public ParameterMetaData getParameterMetaData() throws SQLException {
		// TODO Auto-generated method stub
		return null;
	}

	@Override
	public void setRowId(final int parameterIndex, final RowId x)
			throws SQLException {
		// TODO Auto-generated method stub

	}

	@Override
	public void setNString(final int parameterIndex, final String value)
			throws SQLException {
		// TODO Auto-generated method stub

	}

	@Override
	public void setNCharacterStream(final int parameterIndex,
			final Reader value, final long length) throws SQLException {
		// TODO Auto-generated method stub

	}

	@Override
	public void setNClob(final int parameterIndex, final NClob value)
			throws SQLException {
		// TODO Auto-generated method stub

	}

	@Override
	public void setClob(final int parameterIndex, final Reader reader,
			final long length) throws SQLException {
		// TODO Auto-generated method stub

	}

	@Override
	public void setBlob(final int parameterIndex,
			final InputStream inputStream, final long length)
			throws SQLException {
		// TODO Auto-generated method stub

	}

	@Override
	public void setNClob(final int parameterIndex, final Reader reader,
			final long length) throws SQLException {
		// TODO Auto-generated method stub

	}

	@Override
	public void setSQLXML(final int parameterIndex, final SQLXML xmlObject)
			throws SQLException {
		// TODO Auto-generated method stub

	}

	@Override
	public void setObject(final int parameterIndex, final Object x,
			final int targetSqlType, final int scaleOrLength)
			throws SQLException {
		// TODO Auto-generated method stub

	}

	@Override
	public void setAsciiStream(final int parameterIndex, final InputStream x,
			final long length) throws SQLException {
		// TODO Auto-generated method stub

	}

	@Override
	public void setBinaryStream(final int parameterIndex, final InputStream x,
			final long length) throws SQLException {
		// TODO Auto-generated method stub

	}

	@Override
	public void setCharacterStream(final int parameterIndex,
			final Reader reader, final long length) throws SQLException {
		// TODO Auto-generated method stub

	}

	@Override
	public void setAsciiStream(final int parameterIndex, final InputStream x)
			throws SQLException {
		// TODO Auto-generated method stub

	}

	@Override
	public void setBinaryStream(final int parameterIndex, final InputStream x)
			throws SQLException {
		// TODO Auto-generated method stub

	}

	@Override
	public void setCharacterStream(final int parameterIndex, final Reader reader)
			throws SQLException {
		// TODO Auto-generated method stub

	}

	@Override
	public void setNCharacterStream(final int parameterIndex, final Reader value)
			throws SQLException {
		// TODO Auto-generated method stub

	}

	@Override
	public void setClob(final int parameterIndex, final Reader reader)
			throws SQLException {
		// TODO Auto-generated method stub

	}

	@Override
	public void setBlob(final int parameterIndex, final InputStream inputStream)
			throws SQLException {
		// TODO Auto-generated method stub

	}

	@Override
	public void setNClob(final int parameterIndex, final Reader reader)
			throws SQLException {
		// TODO Auto-generated method stub

	}

	@Override
	public String toString() {
		return "[" + getClass().getSimpleName() + "] " + sql;
	}
}
